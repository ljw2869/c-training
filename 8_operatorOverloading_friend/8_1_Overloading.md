8-1.Overloading
=================
+ 연산자 오버로딩
    - 기존에 c언어에서 제공하고 있는 연산자에 대하여 그 의미를 다시 부여하는 것
    - 다른 말로 연산자 중복(재정의)
    - 함수의 오버로딩과 같이 연산자도 하나의 함수라는 개념을 사용하여 중복 정의
    - 중복되는 연산자 함수는 클래스의 멤버 함수나 프렌드 함수로 정의

    **함수 이름 대신에 operator 키워드를 사용하고 다음에 연산자를 기술**
    > 반환형 operator 연산자(매개변수 리스트);

    - 두 가지 형태로 표현
        * 멤버함수에 의한 오버로딩 ex: v1.operator+(v2)
        * 전역함수에 대한 오버로딩, friend 함수 선언 ex: operator+(v1,v2);

    - 주의사항
        1. 본래의 의도를 벗어난 형태의 연산자 오버로딩은 좋지 않다
        2. 연산자의 우선순위와 결합성은 바뀌지 않는다.
        3. 매개변수의 디폴트 값 설정이 불가능하다.
        4. 연산자의 순수 기능까지 빼앗을 수 없다.
    
    - 연산자 중복의 사례: +
        * 정수 더하기
        * 문자열 합치기
    - cpp에 본래 있는 연산자만 중복 가능
        * 중복이 불가능한 연산자: (.(멤버 선택 연산자), .*(멤버 포인터 연산자), ::(범위지정 연산자),?: (3항 연산자=조건 연산자))
    

    - 피연산자 타입이 다른 새로운 연산 정의
    - 연산자는 함수 형태로 구현 - 연산자 함수(operator function)
    - 반드시 클래스와 관계를 가짐
    - 피연산자의 개수를 바꿀 수 없음
    - 연산의 우선순위 변경이 안됨
    

    - +와 ==의 작성 사례
    ```cpp
    Color a(Blue),b(Red),c;

    c=a+b;
    if(a==b){

    }
    ```
    위와 같은 코드를 작성하기 위해
    1. 외부 함수로 구현되고 클래스에 프렌드로 선언되는 경우
    ```cpp
    Color operator+(Color op1,Color op2);
    bool operator==(Color op1,Color op2);//외부 함수

    class Color{
        friend Color operator+(Color op1,Color op2);
        friend bool operator==(Color op1,Color op2);
    };
    ```
    2. 클래스의 멤버함수로 작성되는 경우
    ```cpp
    class Color{
        Color operator+(Color op2);
        bool operator==(Color op2); // 하나만 넘어오는 이유는 주체가 되는 객체가 있기 때문에 
    };
    ```

    - 연산자 중복의 예시
        vector +연산자 사용
        > (v1+v2+v3); 연산자 중복 사용
        > add(v1,add(v2,v3)); 함수 사용

        string 클래스도 연산자 중복을 이미 하고 있음
